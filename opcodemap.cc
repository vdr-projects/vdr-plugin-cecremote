/*
 * CECRemote PlugIn for VDR
 *
 * Copyright (C) 2016 Ulrich Eckhardt <uli-vdr@uli-eckhardt.de>
 *
 * This code is distributed under the terms and conditions of the
 * GNU GENERAL PUBLIC LICENSE. See the file COPYING for details.
 *
 * opcode.cc: Class for converting CEC commands as string to the
 *            corresponding CEC opcode.
 */

#include "opcodemap.h"

using namespace CEC;
namespace cecplugin {

#define CEC_OPCODE_ADDMAP(X) map->insert(std::pair<std::string, cec_opcode> \
        (#X,CEC_OPCODE_ ## X))

opcodeMap::mapOp *opcodeMap::map = NULL;

void opcodeMap::initMap() {
    if (map != NULL) {
        return;
    }
    map = new (std::map<std::string, cec_opcode>);
    CEC_OPCODE_ADDMAP(ACTIVE_SOURCE);
    CEC_OPCODE_ADDMAP(IMAGE_VIEW_ON);
    CEC_OPCODE_ADDMAP(TEXT_VIEW_ON);
    CEC_OPCODE_ADDMAP(INACTIVE_SOURCE);
    CEC_OPCODE_ADDMAP(REQUEST_ACTIVE_SOURCE);
    CEC_OPCODE_ADDMAP(ROUTING_CHANGE);
    CEC_OPCODE_ADDMAP(ROUTING_INFORMATION);
    CEC_OPCODE_ADDMAP(SET_STREAM_PATH);
    CEC_OPCODE_ADDMAP(STANDBY);
    CEC_OPCODE_ADDMAP(RECORD_OFF);
    CEC_OPCODE_ADDMAP(RECORD_ON);
    CEC_OPCODE_ADDMAP(RECORD_STATUS);
    CEC_OPCODE_ADDMAP(RECORD_TV_SCREEN);
    CEC_OPCODE_ADDMAP(CLEAR_ANALOGUE_TIMER);
    CEC_OPCODE_ADDMAP(CLEAR_DIGITAL_TIMER);
    CEC_OPCODE_ADDMAP(CLEAR_EXTERNAL_TIMER);
    CEC_OPCODE_ADDMAP(SET_ANALOGUE_TIMER);
    CEC_OPCODE_ADDMAP(SET_DIGITAL_TIMER);
    CEC_OPCODE_ADDMAP(SET_EXTERNAL_TIMER);
    CEC_OPCODE_ADDMAP(SET_TIMER_PROGRAM_TITLE);
    CEC_OPCODE_ADDMAP(TIMER_CLEARED_STATUS);
    CEC_OPCODE_ADDMAP(TIMER_STATUS);
    CEC_OPCODE_ADDMAP(CEC_VERSION);
    CEC_OPCODE_ADDMAP(GET_CEC_VERSION);
    CEC_OPCODE_ADDMAP(GIVE_PHYSICAL_ADDRESS);
    CEC_OPCODE_ADDMAP(GET_MENU_LANGUAGE);
    CEC_OPCODE_ADDMAP(REPORT_PHYSICAL_ADDRESS);
    CEC_OPCODE_ADDMAP(SET_MENU_LANGUAGE);
    CEC_OPCODE_ADDMAP(DECK_CONTROL);
    CEC_OPCODE_ADDMAP(DECK_STATUS);
    CEC_OPCODE_ADDMAP(GIVE_DECK_STATUS);
    CEC_OPCODE_ADDMAP(PLAY);
    CEC_OPCODE_ADDMAP(GIVE_TUNER_DEVICE_STATUS);
    CEC_OPCODE_ADDMAP(SELECT_ANALOGUE_SERVICE);
    CEC_OPCODE_ADDMAP(SELECT_DIGITAL_SERVICE);
    CEC_OPCODE_ADDMAP(TUNER_DEVICE_STATUS);
    CEC_OPCODE_ADDMAP(TUNER_STEP_DECREMENT);
    CEC_OPCODE_ADDMAP(TUNER_STEP_INCREMENT);
    CEC_OPCODE_ADDMAP(DEVICE_VENDOR_ID);
    CEC_OPCODE_ADDMAP(GIVE_DEVICE_VENDOR_ID);
    CEC_OPCODE_ADDMAP(VENDOR_COMMAND);
    CEC_OPCODE_ADDMAP(VENDOR_COMMAND_WITH_ID);
    CEC_OPCODE_ADDMAP(VENDOR_REMOTE_BUTTON_DOWN);
    CEC_OPCODE_ADDMAP(VENDOR_REMOTE_BUTTON_UP);
    CEC_OPCODE_ADDMAP(SET_OSD_STRING);
    CEC_OPCODE_ADDMAP(GIVE_OSD_NAME);
    CEC_OPCODE_ADDMAP(SET_OSD_NAME);
    CEC_OPCODE_ADDMAP(MENU_REQUEST);
    CEC_OPCODE_ADDMAP(MENU_STATUS);
    CEC_OPCODE_ADDMAP(USER_CONTROL_PRESSED);
    CEC_OPCODE_ADDMAP(USER_CONTROL_RELEASE);
    CEC_OPCODE_ADDMAP(GIVE_DEVICE_POWER_STATUS);
    CEC_OPCODE_ADDMAP(REPORT_POWER_STATUS);
    CEC_OPCODE_ADDMAP(FEATURE_ABORT);
    CEC_OPCODE_ADDMAP(ABORT);
    CEC_OPCODE_ADDMAP(GIVE_AUDIO_STATUS);
    CEC_OPCODE_ADDMAP(GIVE_SYSTEM_AUDIO_MODE_STATUS);
    CEC_OPCODE_ADDMAP(REPORT_AUDIO_STATUS);
    CEC_OPCODE_ADDMAP(SET_SYSTEM_AUDIO_MODE);
    CEC_OPCODE_ADDMAP(SYSTEM_AUDIO_MODE_REQUEST);
    CEC_OPCODE_ADDMAP(SYSTEM_AUDIO_MODE_STATUS);
    CEC_OPCODE_ADDMAP(SET_AUDIO_RATE);

    /* CEC 1.4 */
    CEC_OPCODE_ADDMAP(START_ARC);
    CEC_OPCODE_ADDMAP(REPORT_ARC_STARTED);
    CEC_OPCODE_ADDMAP(REPORT_ARC_ENDED);
    CEC_OPCODE_ADDMAP(REQUEST_ARC_START);
    CEC_OPCODE_ADDMAP(REQUEST_ARC_END);
    CEC_OPCODE_ADDMAP(END_ARC);
    CEC_OPCODE_ADDMAP(CDC);
    /* when this opcode is set, no opcode will be sent to the device. this is one of the reserved numbers */
    CEC_OPCODE_ADDMAP(NONE);
}

bool opcodeMap::getOpcode(std::string name, cec_opcode &opcode) {
    bool found = false;
    initMap();
    mapOpIterator i = map->find(name);
    if (i != map->end()) {
        found = true;
        opcode = i->second;
    }
    return found;
}

} // namespace cecplugin
